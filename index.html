<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>31 - Blood Moon</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@900&family=Cinzel:wght@700&display=swap" rel="stylesheet">

  <style>
    .svg-filters {
      position: absolute;
      width: 0;
      height: 0;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Cinzel', serif;
      background: #000;
      min-height: 100vh;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Blood rain canvas */
    #rain-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none;
    }

    /* Bat flocks canvas */
    #bats-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 8;
      pointer-events: none;
    }

    /* Background */
    .atmosphere {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      z-index: 0;
    }

    /* Main content */
    .main {
      position: relative;
      z-index: 5;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    /* Moon container - larger for typography focus */
    .blood-moon {
      position: relative;
      width: clamp(400px, 80vmin, 750px);
      height: clamp(400px, 80vmin, 750px);
    }

    /* BACKGLOW - behind everything */
    .moon-backglow {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 170%;
      height: 170%;
      background: radial-gradient(circle, rgba(180, 40, 25, 0.6) 0%, rgba(140, 25, 15, 0.42) 25%, rgba(100, 15, 10, 0.21) 45%, transparent 70%);
      filter: blur(80px);
      z-index: 0;
    }

    /* Moon glow layers */
    .moon-glow {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      animation: glowPulse 6s ease-in-out infinite;
    }

    .moon-glow-outer {
      width: 160%;
      height: 160%;
      background: radial-gradient(circle, rgba(180, 45, 30, 0.5) 0%, rgba(120, 25, 18, 0.25) 45%, transparent 70%);
      filter: blur(50px);
    }

    .moon-glow-mid {
      width: 130%;
      height: 130%;
      background: radial-gradient(circle, rgba(200, 55, 40, 0.4) 0%, transparent 55%);
      filter: blur(35px);
      animation-delay: 1s;
    }

    @keyframes glowPulse {
      0%, 100% { opacity: 0.7; transform: translate(-50%, -50%) scale(1); }
      50% { opacity: 1; transform: translate(-50%, -50%) scale(1.03); }
    }

    /* Moon surface */
    .moon-surface {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: 100%;
      border-radius: 50%;
      overflow: hidden;
      background: #1a0505;
      z-index: 1;
    }

    .moon-image {
      width: 115%;
      height: 115%;
      object-fit: cover;
      border-radius: 50%;
      position: absolute;
      top: 49%;
      left: 50%;
      transform: translate(-50%, -50%);
      filter: url(#blood-red);
    }

    /* Moon softening overlay - behind text */
    .moon-soften {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 70%;
      height: 70%;
      background: radial-gradient(circle, rgba(80, 20, 15, 0.4) 0%, transparent 70%);
      filter: blur(40px);
      z-index: 1;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .moon-soften.active {
      opacity: 1;
    }

    /* THE 31 - LARGE, HERO TYPOGRAPHY */
    .lockup-container {
      position: absolute;
      top: 41%;
      left: 47%;
      transform: translate(-50%, -50%);
      z-index: 2;
    }

    .lockup {
      font-family: 'Cinzel Decorative', serif;
      font-size: clamp(6rem, 55vmin, 50rem);
      font-weight: 900;
      line-height: 0.85;
      letter-spacing: -0.05em;
      color: #050000;
      text-shadow:
        0 0 40px rgba(0, 0, 0, 0.95),
        0 0 80px rgba(0, 0, 0, 0.7),
        3px 3px 6px rgba(0, 0, 0, 0.9),
        -2px -2px 4px rgba(120, 30, 20, 0.2);
      user-select: none;
    }

    /* Carved style */
    .lockup.style-carved {
      color: transparent;
      background: linear-gradient(180deg, rgba(20, 0, 0, 0.95) 0%, rgba(60, 10, 10, 0.85) 50%, rgba(20, 0, 0, 0.95) 100%);
      -webkit-background-clip: text;
      background-clip: text;
      filter: drop-shadow(0 2px 0 rgba(180, 50, 50, 0.4)) drop-shadow(0 -2px 4px rgba(0, 0, 0, 0.8));
      text-shadow: none;
    }

    /* Ember glow style */
    .lockup.style-ember {
      color: #1a0505;
      text-shadow:
        0 0 2px rgba(0, 0, 0, 0.9),
        0 0 20px rgba(139, 26, 26, 0.6),
        0 0 40px rgba(139, 26, 26, 0.4),
        0 0 60px rgba(100, 20, 20, 0.3),
        0 0 100px rgba(80, 10, 10, 0.2);
    }

    /* Blood outline style */
    .lockup.style-outline {
      color: #080000;
      -webkit-text-stroke: 3px rgba(120, 20, 20, 0.7);
      paint-order: stroke fill;
      text-shadow:
        0 0 30px rgba(139, 26, 26, 0.5),
        0 4px 8px rgba(0, 0, 0, 0.8);
    }

    /* Castle silhouette - soft edges, works with 31 */
    .castle-silhouette {
      position: absolute;
      bottom: -30%;
      left: 50%;
      transform: translateX(-50%);
      width: 140%;
      height: 150%;
      z-index: 3;
      pointer-events: auto;
      cursor: pointer;
      filter: blur(5px);
      opacity: 0.95;
    }

    .castle-svg {
      width: 100%;
      height: 100%;
      filter: url(#soften);
    }

    /* Vignette */
    .vignette {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 15;
      background: radial-gradient(ellipse at center, transparent 25%, rgba(0, 0, 0, 0.6) 60%, rgba(0, 0, 0, 0.95) 100%);
    }

    /* Sound Toggle */
    .sound-toggle {
      position: fixed;
      bottom: 1rem;
      right: 1rem;
      z-index: 200;
      background: transparent;
      border: none;
      padding: 0;
      font-family: 'Cinzel', serif;
      font-size: 0.6rem;
      color: #680b0b;
      cursor: pointer;
      letter-spacing: 0.3em;
      text-transform: uppercase;
      transition: color 0.3s ease;
    }

    .sound-toggle:hover {
      color: #a51515;
    }

    /* Footer */
    footer {
      position: fixed;
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      font-family: 'Cinzel', serif;
      font-size: 0.6rem;
      letter-spacing: 0.3em;
      color: #680b0b;
      text-transform: uppercase;
    }

    footer a {
      color: #680b0b;
      text-decoration: none;
      transition: color 0.3s ease;
    }

    footer a:hover {
      color: #a51515;
    }
  </style>
</head>
<body>
  <!-- SVG Filters -->
  <svg class="svg-filters">
    <defs>
      <!-- Blood red filter with user's settings -->
      <filter id="blood-red" color-interpolation-filters="sRGB">
        <feColorMatrix type="saturate" values="0" result="gray"/>
        <feColorMatrix type="matrix" in="gray" values="
          0.60 0.15 0.15 0  0.00
          0.12 0.08 0.04 0  0
          0.02 0.02 0.04 0  0
          0    0    0    1  0
        " result="red"/>
        <feComponentTransfer in="red">
          <feFuncR id="moon-red" type="gamma" amplitude="0.95" exponent="1.0" offset="0"/>
          <feFuncG id="moon-green" type="gamma" amplitude="0.25" exponent="1.1" offset="0"/>
          <feFuncB id="moon-blue" type="gamma" amplitude="0.20" exponent="1.2" offset="0"/>
        </feComponentTransfer>
      </filter>

      <!-- Soften filter for castle -->
      <filter id="soften" x="-5%" y="-5%" width="110%" height="110%">
        <feGaussianBlur in="SourceGraphic" stdDeviation="0.8" result="blur"/>
        <feComposite in="SourceGraphic" in2="blur" operator="over"/>
      </filter>
    </defs>
  </svg>

  <!-- Atmosphere -->
  <div class="atmosphere"></div>

  <!-- Bat flocks canvas -->
  <canvas id="bats-canvas"></canvas>

  <!-- Rain canvas -->
  <canvas id="rain-canvas"></canvas>

  <!-- Vignette -->
  <div class="vignette"></div>

  <!-- Main content -->
  <main class="main">
    <div class="blood-moon">
      <!-- Backglow -->
      <div class="moon-backglow"></div>

      <!-- Glow layers -->
      <div class="moon-glow moon-glow-outer"></div>
      <div class="moon-glow moon-glow-mid"></div>

      <!-- Moon surface -->
      <div class="moon-surface">
        <img
          class="moon-image"
          src="https://upload.wikimedia.org/wikipedia/commons/e/e1/FullMoon2010.jpg"
          alt="Blood Moon"
          crossorigin="anonymous"
        />
      </div>

      <!-- Moon softening overlay -->
      <div class="moon-soften" id="moon-soften"></div>

      <!-- THE 31 - HERO TYPOGRAPHY -->
      <div class="lockup-container">
        <div class="lockup">31</div>
      </div>

      <!-- Castle silhouette - soft edges -->
      <div class="castle-silhouette">
        <svg class="castle-svg" viewBox="0 0 400 220" preserveAspectRatio="xMidYMax meet">
          <path fill="#000" d="
            M200 25 L203 45 L207 25 L211 42 L215 22 L219 40 L223 28
            L223 55 L230 55 L230 45 L234 35 L238 45 L238 55
            L245 55 L245 48 L252 38 L256 35 L260 38 L260 55
            L268 55 L268 65 L275 65 L275 55 L282 45 L286 42 L290 45 L290 65
            L298 65 L298 78 L305 78 L305 68 L312 58 L316 55 L320 58 L320 82
            L330 82 L330 100 L340 100 L340 120 L350 120 L350 220
            L50 220
            L50 120 L60 120 L60 100 L70 100 L70 82
            L80 82 L80 58 L84 55 L88 58 L95 68 L95 78 L102 78 L102 65
            L110 65 L110 45 L114 42 L118 45 L125 55 L125 65 L132 65
            L140 55 L140 38 L144 35 L148 38 L155 48 L155 55
            L162 55 L162 45 L166 35 L170 45 L170 55 L177 55
            L177 28 L181 40 L185 22 L189 42 L193 25 L197 45 L200 25
          "/>
        </svg>
      </div>
    </div>
  </main>

  <!-- Sound Toggle -->
  <button class="sound-toggle" id="sound-toggle">SOUND: OFF</button>

  <footer>Made by <a href="https://github.com/jwzy" target="_blank">Javan Wang</a></footer>

  <script>
    // ============ INITIALIZE ============
    // Apply ember glow style and moon softening on load
    document.querySelector('.lockup').classList.add('style-ember');
    document.getElementById('moon-soften').classList.add('active');

    // ============ MOON PULSE ANIMATION ============
    const moonRed = document.getElementById('moon-red');
    const moonGreen = document.getElementById('moon-green');
    const moonBlue = document.getElementById('moon-blue');
    const baseRedAmplitude = 0.95;
    const baseGreenAmplitude = 0.25;
    const baseBlueAmplitude = 0.20;

    const pulseSpeed = 2.5;
    const pulseAmount = 10;
    let pulseStartTime = performance.now();

    // Ease-in-out easing function
    function easeInOut(t) {
      return (Math.sin(t * Math.PI * 2) * (1 - Math.cos(t * Math.PI * 2)) / 2) + (Math.sin(t * Math.PI * 2) * 0.5);
    }

    function animateMoonPulse(timestamp) {
      const elapsed = (timestamp - pulseStartTime) / 1000;
      const cycleProgress = (elapsed % pulseSpeed) / pulseSpeed;

      const pulseValue = easeInOut(cycleProgress);
      const intensityMultiplier = 1 + (pulseValue * pulseAmount / 100);

      moonRed.setAttribute('amplitude', baseRedAmplitude * intensityMultiplier);
      moonGreen.setAttribute('amplitude', baseGreenAmplitude * intensityMultiplier);
      moonBlue.setAttribute('amplitude', baseBlueAmplitude * intensityMultiplier);

      requestAnimationFrame(animateMoonPulse);
    }
    requestAnimationFrame(animateMoonPulse);

    // ============ AUDIO (BAKED SETTINGS) ============
    // Patter: 0.01, Rumble: 0.19, Wind: 0.09, Master: 0.50
    let audioContext = null;
    let isPlaying = false;
    let audioSources = [];

    const soundToggle = document.getElementById('sound-toggle');

    function createAudio() {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const masterGain = audioContext.createGain();
      masterGain.gain.value = 0.50;
      masterGain.connect(audioContext.destination);

      // Rain patter (high freq) - very subtle
      const patterBuffer = audioContext.createBuffer(2, audioContext.sampleRate * 4, audioContext.sampleRate);
      for (let ch = 0; ch < 2; ch++) {
        const data = patterBuffer.getChannelData(ch);
        for (let i = 0; i < data.length; i++) {
          data[i] = (Math.random() * 2 - 1) * (0.6 + Math.random() * 0.4);
        }
      }
      const patterSource = audioContext.createBufferSource();
      patterSource.buffer = patterBuffer;
      patterSource.loop = true;

      const patterFilter = audioContext.createBiquadFilter();
      patterFilter.type = 'highpass';
      patterFilter.frequency.value = 6000;

      const patterGain = audioContext.createGain();
      patterGain.gain.value = 0.01;

      patterSource.connect(patterFilter);
      patterFilter.connect(patterGain);
      patterGain.connect(masterGain);
      patterSource.start();
      audioSources.push(patterSource);

      // Rain rumble (low freq)
      const rumbleBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 5, audioContext.sampleRate);
      const rumbleData = rumbleBuffer.getChannelData(0);
      for (let i = 0; i < rumbleData.length; i++) {
        rumbleData[i] = Math.random() * 2 - 1;
      }
      const rumbleSource = audioContext.createBufferSource();
      rumbleSource.buffer = rumbleBuffer;
      rumbleSource.loop = true;

      const rumbleFilter = audioContext.createBiquadFilter();
      rumbleFilter.type = 'lowpass';
      rumbleFilter.frequency.value = 250;

      const rumbleGain = audioContext.createGain();
      rumbleGain.gain.value = 0.19;

      rumbleSource.connect(rumbleFilter);
      rumbleFilter.connect(rumbleGain);
      rumbleGain.connect(masterGain);
      rumbleSource.start();
      audioSources.push(rumbleSource);

      // Wind
      const windBuffer = audioContext.createBuffer(2, audioContext.sampleRate * 6, audioContext.sampleRate);
      for (let ch = 0; ch < 2; ch++) {
        const data = windBuffer.getChannelData(ch);
        for (let i = 0; i < data.length; i++) {
          data[i] = Math.random() * 2 - 1;
        }
      }
      const windSource = audioContext.createBufferSource();
      windSource.buffer = windBuffer;
      windSource.loop = true;

      const windFilter = audioContext.createBiquadFilter();
      windFilter.type = 'bandpass';
      windFilter.frequency.value = 400;
      windFilter.Q.value = 1.5;

      const lfo = audioContext.createOscillator();
      const lfoGain = audioContext.createGain();
      lfo.frequency.value = 0.1;
      lfoGain.gain.value = 180;
      lfo.connect(lfoGain);
      lfoGain.connect(windFilter.frequency);
      lfo.start();
      audioSources.push(lfo);

      const windGain = audioContext.createGain();
      windGain.gain.value = 0.09;

      windSource.connect(windFilter);
      windFilter.connect(windGain);
      windGain.connect(masterGain);
      windSource.start();
      audioSources.push(windSource);

      isPlaying = true;
      soundToggle.textContent = 'SOUND: ON';
    }

    function stopAudio() {
      audioSources.forEach(s => { try { s.stop(); } catch(e) {} });
      audioSources = [];
      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }
      isPlaying = false;
      soundToggle.textContent = 'SOUND: OFF';
    }

    soundToggle.addEventListener('click', () => {
      if (isPlaying) stopAudio();
      else createAudio();
    });

    // Auto-start audio on first user interaction
    function autoStartAudio() {
      if (!isPlaying) {
        try {
          createAudio();
        } catch (e) {
          console.log('Audio autostart failed:', e);
        }
      }
      document.removeEventListener('click', autoStartAudio, true);
      document.removeEventListener('keydown', autoStartAudio, true);
      document.removeEventListener('touchstart', autoStartAudio, true);
    }
    document.addEventListener('click', autoStartAudio, true);
    document.addEventListener('keydown', autoStartAudio, true);
    document.addEventListener('touchstart', autoStartAudio, true);

    // ============ FAST BAT FLOCKS WITH MOTION BLUR ============
    const batsCanvas = document.getElementById('bats-canvas');
    const batsCtx = batsCanvas.getContext('2d');

    // Background bat parameters (locked in)
    const batSpeedMult = 1.0;
    const batFreqMult = 2.0;
    const batSizeMult = 0.3;
    const batDirectionMode = 'both';
    const batMotionMode = 'wave';

    // Swarm bat parameters (locked in, except swarm spread)
    const swarmCount = 195;
    const swarmSpeedMult = 2.0;
    const swarmStartSize = 0.01;
    const swarmErratic = 2.0;
    const swarmScaleSpeed = 1.8;
    const swarmSpread = 4.0; // Controls spawn area size

    function resizeBatsCanvas() {
      batsCanvas.width = window.innerWidth;
      batsCanvas.height = window.innerHeight;
    }
    resizeBatsCanvas();
    window.addEventListener('resize', resizeBatsCanvas);

    class BatFlock {
      constructor() {
        this.reset();
      }

      reset() {
        this.active = false;
        this.x = -100;
        this.y = Math.random() * batsCanvas.height * 0.6 + batsCanvas.height * 0.1;
        this.baseSpeed = 15 + Math.random() * 20;
        this.bats = [];
        const count = 8 + Math.floor(Math.random() * 18);
        for (let i = 0; i < count; i++) {
          this.bats.push({
            offsetX: Math.random() * 180 - 90,
            offsetY: Math.random() * 140 - 70,
            baseSize: 8 + Math.random() * 15,
            phase: Math.random() * Math.PI * 2
          });
        }
      }

      activate() {
        this.active = true;
        this.startY = Math.random() * batsCanvas.height * 0.5 + batsCanvas.height * 0.15;
        this.y = this.startY;
        this.baseSpeed = 18 + Math.random() * 25;
        this.travelDistance = 0;

        // Direction based on mode
        if (batDirectionMode === 'left') {
          this.direction = 1;
        } else if (batDirectionMode === 'right') {
          this.direction = -1;
        } else {
          this.direction = Math.random() > 0.3 ? 1 : -1;
        }

        this.x = this.direction > 0 ? -100 : batsCanvas.width + 100;
      }

      update() {
        if (!this.active) return;
        const speed = this.baseSpeed * batSpeedMult;
        this.x += speed * this.direction;
        this.travelDistance += speed;

        // Apply motion pattern to flock Y position
        const progress = this.travelDistance / batsCanvas.width;
        switch (batMotionMode) {
          case 'straight':
            this.y = this.startY;
            break;
          case 'wave':
            this.y = this.startY + Math.sin(progress * Math.PI * 2) * 50;
            break;
          case 'dive':
            this.y = this.startY + progress * 150;
            break;
          case 'rise':
            this.y = this.startY - progress * 150;
            break;
          case 'erratic':
            this.y = this.startY + Math.sin(progress * Math.PI * 8) * 80 * Math.sin(progress * Math.PI * 3);
            break;
        }

        if ((this.direction > 0 && this.x > batsCanvas.width + 150) ||
            (this.direction < 0 && this.x < -150)) {
          this.active = false;
        }
      }

      draw(time) {
        if (!this.active) return;
        const speed = this.baseSpeed * batSpeedMult;

        this.bats.forEach(bat => {
          const size = bat.baseSize * batSizeMult;
          const bx = this.x + bat.offsetX;
          const waveOffset = batMotionMode === 'wave' ? 0 : Math.sin(time * 0.01 + bat.phase) * 8;
          const by = this.y + bat.offsetY + waveOffset;

          // Motion blur trail
          batsCtx.globalAlpha = 0.15;
          for (let i = 5; i > 0; i--) {
            const trailX = bx - (speed * this.direction * i * 0.3);
            drawBat(trailX, by, size * 0.8, time + bat.phase);
          }

          // Main bat
          batsCtx.globalAlpha = 0.9;
          drawBat(bx, by, size, time + bat.phase);
        });

        batsCtx.globalAlpha = 1;
      }
    }

    // Bat SVG path (140x51 original size)
    const batPath = new Path2D('M140 2.77249C133.209 0.136343 124.446 -0.511253 116.045 0.372104C99.9632 2.06322 87.3983 9.25541 79.3326 20.3183C76.4554 17.3151 74.7157 13.5369 74.6695 9.42054C72.4969 11.5374 70.9252 14.0801 70.131 16.8694C69.3367 14.0791 67.7651 11.5374 65.5925 9.42054C65.5463 13.6085 63.7505 17.4523 60.7794 20.4804C52.7194 9.32604 40.1153 2.07117 23.9546 0.372104C15.5528 -0.511253 6.78953 0.135349 0 2.77249C15.4799 4.46061 19.7214 11.3444 17.1272 18.28C29.3644 15.6598 41.3788 24.3929 37.4566 34.5694C40.7092 33.4602 45.3808 33.1548 49.6545 33.5567C59.8745 34.5186 67.1585 41.9963 69.9937 51C69.9951 50.9901 69.9979 50.9781 70.0007 50.9662C70.0021 50.9781 70.0063 50.9901 70.0077 51C72.8443 41.9963 80.1269 34.5186 90.3483 33.5567C94.6206 33.1548 99.2922 33.4592 102.543 34.5694C98.6212 24.3938 110.637 15.6607 122.874 18.28C120.279 11.3444 124.521 4.46061 140 2.77249Z');
    const batOrigWidth = 140;
    const batOrigHeight = 51;

    function drawBat(x, y, size, time) {
      const scale = size / 20;
      batsCtx.save();
      batsCtx.translate(x - (batOrigWidth * scale) / 2, y - (batOrigHeight * scale) / 2);
      batsCtx.scale(scale, scale);
      batsCtx.fillStyle = '#000';
      batsCtx.fill(batPath);
      batsCtx.restore();
    }

    const flocks = [];
    for (let i = 0; i < 4; i++) {
      flocks.push(new BatFlock());
    }

    // Spawn flocks intermittently
    let spawnTimeout;
    function maybeSpawnFlock() {
      const inactiveFlock = flocks.find(f => !f.active);
      if (inactiveFlock && Math.random() > 0.7) {
        inactiveFlock.activate();
      }
      const baseDelay = 2000 + Math.random() * 4000;
      spawnTimeout = setTimeout(maybeSpawnFlock, baseDelay / batFreqMult);
    }
    setTimeout(maybeSpawnFlock, 1000);

    let batTime = 0;
    const swarmBats = [];

    function animateBats() {
      batsCtx.clearRect(0, 0, batsCanvas.width, batsCanvas.height);
      batTime++;

      // Regular flocks
      flocks.forEach(flock => {
        flock.update();
        flock.draw(batTime);
      });

      // Swarm bats
      for (let i = swarmBats.length - 1; i >= 0; i--) {
        swarmBats[i].update();
        swarmBats[i].draw();
        if (!swarmBats[i].active) {
          swarmBats.splice(i, 1);
        }
      }

      requestAnimationFrame(animateBats);
    }
    animateBats();


    // ============ SWARM BATS (FLY TOWARDS CAMERA) ============
    const swarmBatSize = 1.0; // Locked size for swarm bats

    class SwarmBat {
      constructor(startX, startY) {
        this.x = startX;
        this.y = startY;
        // Random direction spreading outward, biased upward
        const angle = -Math.PI / 2 + (Math.random() - 0.5) * Math.PI * 1.4;
        const speed = (4 + Math.random() * 6) * swarmSpeedMult;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.flightAngle = angle; // Store flight direction
        this.scale = swarmStartSize;
        this.scaleSpeed = (0.012 + Math.random() * 0.018) * swarmScaleSpeed;
        this.opacity = 1;
        // Base rotation from flight angle - bat faces direction of travel
        // Add small random wobble for natural look
        this.baseRotation = angle + Math.PI / 2; // Rotate so bat "top" faces flight direction
        this.wobble = 0;
        this.wobbleAmount = (Math.random() - 0.5) * 0.3; // Small wobble variation
        this.wobbleSpeed = (Math.random() - 0.5) * 0.1 * swarmErratic;
        this.active = true;
        this.flutter = Math.random() * Math.PI * 2;
        this.flutterSpeed = 0.2 + Math.random() * 0.3;
        // Erratic movement
        this.erraticPhase = Math.random() * Math.PI * 2;
        this.erraticFreq = 0.1 + Math.random() * 0.2;
      }

      update() {
        if (!this.active) return;

        // Erratic movement
        const erraticX = Math.sin(this.erraticPhase) * swarmErratic * 2;
        const erraticY = Math.cos(this.erraticPhase * 1.3) * swarmErratic * 1.5;
        this.erraticPhase += this.erraticFreq;

        // Move outward, accelerating as they get closer
        this.x += this.vx * (1 + this.scale * 3) + erraticX;
        this.y += this.vy * (1 + this.scale * 3) + erraticY;

        // Scale up (flying towards camera)
        this.scale += this.scaleSpeed * (1 + this.scale);

        // Flutter effect
        this.flutter += this.flutterSpeed;
        // Small wobble in rotation, not full random spin
        this.wobble += this.wobbleSpeed;

        // Fade out as they get close
        if (this.scale > 1.2) {
          this.opacity -= 0.03;
        }

        // Deactivate when fully faded or off screen
        if (this.opacity <= 0 || this.scale > 5) {
          this.active = false;
        }
      }

      draw() {
        if (!this.active) return;

        const size = 20 * this.scale * swarmBatSize;
        const flutter = Math.sin(this.flutter) * 0.2;
        const rotation = this.baseRotation + Math.sin(this.wobble) * this.wobbleAmount;

        batsCtx.save();
        batsCtx.globalAlpha = this.opacity * 0.9;
        batsCtx.translate(this.x, this.y);
        batsCtx.rotate(rotation);
        batsCtx.scale(1 + flutter, 1 - flutter * 0.5);
        batsCtx.translate(-(batOrigWidth * size / 20) / 2, -(batOrigHeight * size / 20) / 2);
        batsCtx.scale(size / 20, size / 20);
        batsCtx.fillStyle = '#000';
        batsCtx.fill(batPath);
        batsCtx.restore();
      }
    }

    function triggerBatSwarm() {
      const startX = batsCanvas.width / 2;
      const startY = batsCanvas.height * 0.85;

      for (let i = 0; i < swarmCount; i++) {
        setTimeout(() => {
          const offsetX = (Math.random() - 0.5) * 150 * swarmSpread;
          const offsetY = Math.random() * 50 * swarmSpread;
          swarmBats.push(new SwarmBat(startX + offsetX, startY + offsetY));
        }, i * 8);
      }
    }

    // Bat swarm sound
    const batSwarmSound = new Audio('bat-flying-sounds.mp3');
    let batSoundFadeInterval = null;

    function playBatSound() {
      // Clear any existing fade
      if (batSoundFadeInterval) clearInterval(batSoundFadeInterval);

      batSwarmSound.volume = 0.2;
      batSwarmSound.currentTime = 0;
      batSwarmSound.play();

      // After 2 seconds, fade out quickly
      setTimeout(() => {
        batSoundFadeInterval = setInterval(() => {
          if (batSwarmSound.volume > 0.05) {
            batSwarmSound.volume -= 0.05;
          } else {
            batSwarmSound.pause();
            batSwarmSound.volume = 0.2;
            clearInterval(batSoundFadeInterval);
          }
        }, 30);
      }, 2000);
    }

    // Castle click handler
    document.querySelector('.castle-silhouette').addEventListener('click', (e) => {
      e.stopPropagation();
      triggerBatSwarm();
      playBatSound();
    });

    // ============ BLOOD RAIN - MORE VISIBLE ============
    const rainCanvas = document.getElementById('rain-canvas');
    const ctx = rainCanvas.getContext('2d');

    function resizeCanvas() {
      rainCanvas.width = window.innerWidth;
      rainCanvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    class BloodDrop {
      constructor() { this.reset(); }

      reset() {
        this.x = Math.random() * rainCanvas.width;
        this.y = -30;
        this.length = Math.random() * 40 + 30;
        this.speed = Math.random() * 10 + 14;
        this.width = Math.random() * 3 + 1.5;
        this.opacity = Math.random() * 0.5 + 0.25;
      }

      update() {
        this.y += this.speed;
        if (this.y > rainCanvas.height) this.reset();
      }

      draw() {
        const gradient = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.length);
        gradient.addColorStop(0, `rgba(100, 10, 10, 0)`);
        gradient.addColorStop(0.2, `rgba(140, 20, 20, ${this.opacity})`);
        gradient.addColorStop(0.6, `rgba(100, 15, 15, ${this.opacity * 0.8})`);
        gradient.addColorStop(1, `rgba(60, 5, 5, 0)`);

        ctx.beginPath();
        ctx.strokeStyle = gradient;
        ctx.lineWidth = this.width;
        ctx.lineCap = 'round';
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x, this.y + this.length);
        ctx.stroke();
      }
    }

    const drops = [];
    for (let i = 0; i < 200; i++) {
      const drop = new BloodDrop();
      drop.y = Math.random() * rainCanvas.height;
      drops.push(drop);
    }

    function animateRain() {
      ctx.clearRect(0, 0, rainCanvas.width, rainCanvas.height);
      drops.forEach(drop => { drop.update(); drop.draw(); });
      requestAnimationFrame(animateRain);
    }
    animateRain();
  </script>
</body>
</html>
